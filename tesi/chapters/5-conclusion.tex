\chapter{Conclusion}

\section{Summary}

\subsection{Results}

From the testing phase, we can conclude that the protocol is feasible and functional. The performance of the homomorphic encryption scheme is acceptable for a real-world scenario, although it is still computationally more expensive than a traditional RSA solution. However, it can be applied in a zero-trust scenario, where the server cannot be trusted to handle sensitive data. The introduction of PRE (Proxy Re-Encryption) allows us to offload the computation to a trusted third party, which can be used to compute the distances between the client position and the parking spots without revealing the client position to the server. Moreover, this resolved the previous issue of the server possible leak of client position, under the threat model~\cref{subsec:threatmodel}.

\subsection{Protocol Scalability}

One more factor to consider is the scalability of the protocol. The MCs and LDs can be scaled horizontally, meaning that we can add more servers to handle more clients and parking spots. The same applies to the server and workers; for instance, we can have multiple servers handling different areas of the metropolis, each with its own set of parking spots. However, the CA (Certificate Authority) is not. Moreover, the CA could have multiple instances, but they would need to be synchronized in order to issue certificates for the same client.

\subsection{Protocol Limitations}

In conclusion, the protocol presented in this thesis is a feasible solution for the problem of finding nearby parking spots in a zero-trust scenario. This was possible thanks to the correct usage of the right network protocols, such as the publish/subscribe and request/response protocols. During my work, I concluded that even though the publish/subscribe protocol is preferred for this kind of applications, it does not match the requirements of a zero-trust scenario. Moreover, working with homomorphic encryption adds the requirement that the server is not allowed to know the plain text of the clients. This is a crucial point, as it does not allow us to infer informations from the client data. So, the request/response protocol works better in this sense: the client request anonymously a service, the server responds applying a list of operations to the encrypted data, and then the client can decrypt the result. In the opposite case, the server would need to know \emph{when} to respond to the client, which is most of the time a consequence of a side-effect to the request. Let's consider the case the LA-MQTT protocol \cref{sec:la-mqtt}: the client subscribes to a topic, and the server publishes the result based on the client location. In this case, is obvious that the server needs to know the client position in order to publish the result. Indeed, if this was the case, we would not be able to apply the homomorphic encryption scheme.

If we were to design a truly zero-trust protocol, no dependency on a central Certificate Authority (CA) would be necessary. This is a common practice today, especially in blockchain-based systems, where the CA is replaced by a distributed ledger. However, such a change would require a complete redesign of the protocol, as the CA currently handles certificate issuance for both clients and parking spots. It would also necessitate a different approach to client and parking spot authentication and authorization.

Furthermore, this change would significantly increase the computational burden on each sensor. Each sensor would first need to verify whether a client is authorized to access its data, and then encrypt the data using the client’s public key. In our case study, this is not feasible, as Location Detectors (LDs) are resource-constrained devices that cannot perform such complex and frequent cryptographic operations.

\section{Future Works}

Several areas for future improvement were identified during the testing phase. One of them is the possible integration of IoT specific libraries, such as the \emph{SEAL Embedded} \cite{sealembedded} library, which is designed for resource-constrained devices. This would allow us to run the protocol on edge devices, such as sensors or micro-controllers more efficiently. However, this change would require adapting the entire system to use the Microsoft SEAL\cite{sealcrypto} library across all components.

Another significant area of potential optimization involves adjacency calculation using z-order encoding and Fully Homomorphic Encryption (FHE). In~\cite{zhang2020privacy}, the authors propose a standard for computing meaningful queries over homomorphically encrypted, position-related data. Although their context was a social media platform tracking user locations to suggest nearby friends, the methods are highly relevant here. Their approach uses z-order encoding not only to encode spatial data but also to support privacy-preserving preference levels.
For example, a user may wish to share their location with a friend, but not reveal the exact position. By applying a preference bitmask, the user can selectively disclose only a coarser granularity of the z-order encoding. The paper also demonstrates how to compute the exact distance between two points by constructing the smallest encoded bounding box that contains them—entirely under encryption. Integrating such concepts into our protocol could allow us not only to identify parking spots in the same area but also to estimate distances securely.
Our encoding strategy is based on converting GPS coordinates into z-order curves, offering an approximate but compact representation of spatial areas. While this encoding introduces a certain error margin, the trade-off may be acceptable—or even beneficial—as it contributes to obfuscating the precise location of the user.

