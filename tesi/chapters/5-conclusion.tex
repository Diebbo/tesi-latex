\chapter{Conclusion}

\section{Summary}

\subsection{Results}

From the testing phase, we can conclude that the protocol is feasible and functional. The performance of the homomorphic encryption scheme is acceptable for a real-world scenario, although it is still computationally more expensive than a traditional RSA solution. However, it can be applied in a zero-trust scenario, where the server cannot be trusted to handle sensitive data. The introduction of PRE (Proxy Re-Encryption) allows us to offload the computation to a trusted third party, which can be used to compute the distances between the client position and the parking spots without revealing the client position to the server. Moreover, this resolved the previous issue of the server possible leak of client position, under the threat model~\cref{subsec:threatmodel}.

\subsection{Protocol Scalability}

One more factor to consider is the scalability of the protocol. The MCs and LDs can be scaled horizontally, meaning that we can add more servers to handle more clients and parking spots. The same applies to the server and workers; for instance, we can have multiple servers handling different areas of the metropolis, each with its own set of parking spots. However, the CA (Certificate Authority) is not. Moreover, the CA could have multiple instances, but they would need to be synchronized in order to issue certificates for the same client.

\subsection{Protocol Limitations}

In conclusion, the protocol presented in this thesis is a feasible solution for the problem of finding nearby parking spots in a zero-trust scenario. This was possible thanks to the correct usage of the right network protocols, such as the publish/subscribe and request/response protocols. During my work, I concluded that even though the publish/subscribe protocol is preferred for this kind of applications, it does not match the requirements of a zero-trust scenario. Moreover, working with homomorphic encryption adds the requirement that the server is not allowed to know the plain text of the clients. This is a crucial point, as it does not allow us to infer informations from the client data. So, the request/response protocol works better in this sense: the client request anonymously a service, the server responds applying a list of operations to the encrypted data, and then the client can decrypt the result. In the opposite case, the server would need to know \emph{when} to respond to the client, which is most of the time a consequence of a side-effect to the request. Let's consider the case the LA-MQTT protocol \cref{sec:la-mqtt}: the client subscribes to a topic, and the server publishes the result based on the client location. In this case, is obvious that the server needs to know the client position in order to publish the result. Indeed, if this was the case, we would not be able to apply the homomorphic encryption scheme.

\section{Future Works}

During the testing phase, we identified several areas for improvement for future work. One of them is the possible integration of IoT specific libraries, such as the \emph{SEAL Embedded} \cite{sealembedded} library, which is designed for resource-constrained devices. This would allow us to run the protocol on edge devices, such as sensors or micro-controllers, without the need for a powerful server. The obvious constraint is that the whole system should be adapted to work with the Microsoft SEAL\cite{sealcrypto} Library also on the server side. 

Another huge area of possible optimization is the adjacency calculation using z-order encoding and FHE. In the paper \cite{zhang2020privacy}, they proposed a standard for computing useful queries on homomorphic encrypted position-related data. In their work, they were considering a social media application, that was collecting user positions to show nearby friends. Their work not only showcased that you can apply z-order encoding to encode positions, but comes really handy when using preference levels for positions sharing. Let's consider the following example: a user wants to share his position with a friend, he does not trust him enough to share his exact location. Instead, he can apply a preference bit-mask in order to share only a certain order level of the z-order encoding. The paper also shows that is possible to compute the exact distance between two positions: the main idea is to create the smallest encoded box that contains both positions even in FHE. This concept could be applied to our protocol, allowing us not only to find parkings sharing our same area, but also to compute the distance between a particular parking.

Our encoding standard is based on the transformation of GPS coordinates into a z-order curve, thus an approximate representation of an area. When applying this encoding, we need to consider the order of magnitude of the error introduced by the encoding. That doesn't always mean that the error is negligible, but at the same time could also work in our favor, as it allows to obfuscate an exact position.

