\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\chapter{Testing}
\section{Testing Methodology}

For the testing of the protocol, we implemented a proof-of-concept in Python, using the OpenFHE library\cite{openFHE}. The testing methodology consists of the following steps: firstly, we generate a set of random positions for the parking spots. After that we generated a random position for the client, we computed the z-order encoding for both the client and the parking spots, and finally we computed the distances between the client position and the parking spots using the homomorphic encryption scheme.

At the same time, we also computed the distance calculation using a clear computation (trusted backend) with traffic in encrypted with asymmetric encryption (RSA). This allows us to compare the performance of the homomorphic encryption scheme with a traditional asymmetric encryption scheme.

The testing environment consists of a virtual machine instance on a server, with the following specifications:
\begin{itemize}
    \item CPU: Intel(R) Xeon(R) Silver 4110 CPU @ 2.10GHz 16 cores
    \item RAM: 64 GB
    \item OS: Debian 11
    \item Python version: 3.8
    \item OpenFHE version: 1.3.0.0.20.4
    \item numpy version: 1.24.0
\end{itemize}

\section{Performance Evaluation}

The first test that we performed was to measure the time taken to encrypt and decrypt the client position using the homomorphic encryption scheme. The results are shown in Figure \ref{fig:testing-enc}. The time taken to encrypt around 50 parkings with the same key is around 0.5 seconds, while the time taken to decrypt the client position is around 0.2 seconds. This shows that the homomorphic encryption scheme is efficient for this use case, but it still grows linearly with the number of data points.

\begin{figure}[h]
    \centering
    \includegraphics[width=8.5cm,height=7cm]{img/crypto_times.png}
    \caption{Visualization of the Encryption and Decryption time using HE}
    \label{fig:testing-enc}
\end{figure}

The test begins with the generation of the parameters for the homomorphic encryption scheme, followed by the key generation. The code snippet in Listing \ref{lst:enc-decrypt} shows the code used to encrypt and decrypt the client position.
% add the code to encrypt
\lstset{frame=tb,
  language=python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{magenta},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\newpage

\begin{lstlisting}[language=python, caption={Encryption and Decryption of the client position}, label={lst:enc-decrypt}]
parameters = CCParamsBGVRNS()
parameters.SetPlaintextModulus(65537)
parameters.SetMultiplicativeDepth(2)

crypto_context = GenCryptoContext(parameters)
crypto_context.Enable(PKESchemeFeature.PKE)
crypto_context.Enable(PKESchemeFeature.KEYSWITCH)
crypto_context.Enable(PKESchemeFeature.LEVELEDSHE)

keypair = crypto_context.KeyGen()
crypto_context.EvalMultKeyGen(keypair.secretKey)
\end{lstlisting}


The next step is to compute the distances between the client position and the parking spots. The code snippet in Listing \ref{lst:compute-distances} shows the code used to compute the distances using the homomorphic encryption scheme.

\begin{lstlisting}[caption={Computing distances using Homomorphic Encryption}, label={lst:compute-distances}]
# Encrypt the client position
query_plaintext = crypto_context.MakePackedPlaintext([query_encoded])
query_ciphertext = crypto_context.Encrypt(keypair.publicKey, query_plaintext)

# Process each spot
spots = parking_system.get_spots()

for spot_id, spot in spots.items():
    # Create plaintext for the spot's encoded position
    spot_plaintext = crypto_context.MakePackedPlaintext([spot['encoded_pos']])
    
    # Homomorphic subtraction to check if positions match
    diff_ciphertext = crypto_context.EvalSub(query_ciphertext, spot_plaintext)
                
    diff_plaintext = crypto_context.Decrypt(keypair.secretKey, diff_ciphertext)

\end{lstlisting}

I have extracted this two sections from the original codebase to showcase how the encryption distance calculation works. The full code contains additional logic for handling metrics and logging.

In order to have a fair comparison with other common encryption standards, I made the test run in parallel by multi-processing on the same machine. This made the test more realistic, as in a real-world scenario, multiple clients would be sending requests to the server at the same time with more and more parking spots (subscribers).

\begin{figure}[h]
    \centering
    \includegraphics[width=8.5cm,height=7cm]{img/total_time_comparison.png}
    \caption{Comparison between RSA and HE for encryption and decryption}
    \label{fig:he-vs-rsa}
\end{figure}

The overall time performance of the protocol is shown in Figure \ref{fig:he-vs-rsa} remarked what we already expected: the HE standard has some overhead compared to the RSA standard, but it is still acceptable for a real-world scenario. The main difference from the two encryption standard is that with the symmetric encryption the server, after decrypting the client position, is much faster in computing the distances, as it can be achieved in a couple of instructions.

\[
    distance = \sqrt{(x_1 - x_2)^2 + (y_1 - y_2)^2}
\]

Although the homomorphic encryption needs to perform a simple subtraction, it is still slower as values need to be packed to match HE standards \ref{lst:compute-distances}.

It also worth to mention the way the distances are computed in our protocol. Firstly, we need to encode the GPS coordinates into a grid-like structure. This operation is essential to ensure that we are considering small areas instead of points. Then we apply a unique encoding to the grid coordinates, transforming them from a two-dimensional grid into a one-dimensional z-order curve. By having a single integer representation we can perform easily the distance.

\begin{lstlisting}[caption={Distance computation using z-order encoding}, label={lst:distance-computation}]
def calculate_grid_sizes_for_radius(radius_meters, max_lat, min_lat, max_lon, min_lon):
    radius_km = radius_meters / 1000.0
    lat_span = max_lat - min_lat
    lon_span = max_lon - min_lon
    
    # Latitude: fixed ~111.32 km/degree
    lat_cells = int(lat_span / (radius_km / 111.32))
    
    # Longitude: depends on latitude
    mean_lat = math.radians((max_lat + min_lat) / 2)
    lon_cells = int(lon_span / (radius_km / (111.32 * math.cos(mean_lat))))
    
    return lat_cells, lon_cells  # Return separate sizes

def normalize_gps(lat, lon, lat_cells=None, lon_cells=None, edge_meters=500, max_lat=44.499194, min_lat=44.492307, max_lon=11.363250, min_lon=11.325319):

    if lat_cells is None or lon_cells is None:
        lat_cells, lon_cells = calculate_grid_sizes_for_radius(edge_meters, max_lat, min_lat, max_lon, min_lon)
    
    grid_x = int((lat - min_lat) / (max_lat - min_lat) * lat_cells)
    grid_y = int((lon - min_lon) / (max_lon - min_lon) * lon_cells)
    
    return grid_x, grid_y
\end{lstlisting}

To compute the z-order encoding, we use a straightforward approach that interleaves the bits of the x and y coordinates. The code snippet in Listing \ref{lst:z-order-encoding} shows how we compute the z-order encoding for the grid coordinates.

\begin{lstlisting}[caption={Z-order encoding for grid coordinates}, label={lst:z-order-encoding}]
def interleave_bits(x, y):
    """
    Interleave the bits of x and y to create a Morton code.
    x and y should be non-negative integers, each limited to 16 bits.
    """
    # Ensure inputs are within 16-bit range
    x = min(x, 0xFFFF)
    y = min(y, 0xFFFF)
    
    # Convert to binary and pad with zeros to 16 bits
    x_bin = format(x, '016b')
    y_bin = format(y, '016b')
    
    # Interleave the bits
    result = ''
    for i in range(16):
        result += x_bin[i] + y_bin[i]
    
    return int(result, 2)
\end{lstlisting}


There are also other approaches to compute distances between two encrypted points\cite{ibarrond2022hedistancetricks}, such as:
\begin{itemize}
    \item \textbf{Cosine similarity:} normally calculated as 
    $
    \mathrm{CS}(\mathbf{x}, \mathbf{y}) = \frac{\sum_i x_i y_i}{\|\mathbf{x}\| \cdot \|\mathbf{y}\|}
    $
    which requires computing a division and a norm. This can be resolved by normalizing the vectors, i.e., $\mathbf{x}' = \mathbf{x} / \|\mathbf{x}\|$ and $\mathbf{y}' = \mathbf{y} / \|\mathbf{y}\|$, encrypting $\mathbf{x}'$ and $\mathbf{y}'$, and then performing a simple scalar product: $\sum_i x'_i y'_i$.
    
    \item \textbf{Euclidean Distance:} defined as
    $
    \mathrm{ED}(\mathbf{x}, \mathbf{y}) = \sqrt{\sum_i (x_i - y_i)^2}
    $
    which would require a square root operation.\\
    Instead we use the \textbf{Squared Euclidean Distance} instead:
    $
    \mathrm{SED}(\mathbf{x}, \mathbf{y}) = \sum_i (x_i - y_i)^2
    $
    
    \item \textbf{Manhattan Distance:} defined as
    $
    \mathrm{MD}(\mathbf{x}, \mathbf{y}) = \sum_i |x_i - y_i|
    $
    which would require computing the absolute value.\\
    If you encrypt only binary values (i.e., $\hat{\mathbf{x}}, \hat{\mathbf{y}}$ such that $\hat{x}_i, \hat{y}_i \in \{0,1\}$ for all $i$), you can reformulate:
    $
    \mathrm{MD}(\hat{\mathbf{x}}, \hat{\mathbf{y}}) = \sum_i (\hat{x}_i - \hat{y}_i)^2 = \mathrm{HD}(\hat{\mathbf{x}}, \hat{\mathbf{y}})
    $
    which is the \textbf{Hamming Distance} . For non-binary vectors, you can at least compute the \textbf{Squared Manhattan Distance}
    $
    \mathrm{SMD}(\mathbf{x}, \mathbf{y}) = \sum_i (x_i - y_i)^2
    $
    but this is missing a square root to recover the standard Manhattan distance.
    
\end{itemize}

Rounding off, all of this methods relies on the fact that you still need to compute calculation on floatting point numbers, which is not ideal for homomorphic encryption. Another way could be to normalize the cordinates to integers, with a fixed order of magnituted, but at this point it is not worth the effort as the z-order encoding is already a good solution for this problem.


\section{Security Analysis}



\section{Conclusions and Future Works}

From the testing phase, we can conclude that the protocol is feasible and functional. The performance of the homomorphic encryption scheme is acceptable for a real-world scenario, although it is still computationally more expensive than a traditional RSA solution. However, it can be applied in a zero-trust scenario, where the server cannot be trusted to handle sensitive data. The introduction of PRE (Proxy Re-Encryption) allows us to offload the computation to a trusted third party, which can be used to compute the distances between the client position and the parking spots without revealing the client position to the server. Moreover, this resolved the previous issue of the server possible leak of client position, under the threat model~\cref{subsec:threatmodel}.

One more factor to consider is the scalability of the protocol. The MCs and LDs can be scaled horizontally, meaning that we can add more servers to handle more clients and parking spots. The same applies to the server and workers; for instance, we can have multiple servers handling different areas of the metropolis, each with its own set of parking spots. However, the CA (Certificate Authority) is not. Moreover, the CA could have multiple instances, but they would need to be synchronized in order to issue certificates for the same client.

During the testing phase, we identified several areas for improvement for future work. One of them is the possible integration of IoT specific libraries, such as the \emph{SEAL Embedded} library, which is designed for resource-constrained devices. This would allow us to run the protocol on edge devices, such as sensors or micro-controllers, without the need for a powerful server. The obvious constraint is that the whole system should be adapted to work with the Microsoft SEAL\cite{sealcrypto} Library also on the server side. 

Another huge area of possible optimization is the adjacency calculation using z-order encoding and FHE. In the paper \cite{zhang2020privacy}, they proposed a standard for computing useful queries on homomorphic encrypted position-related data. In their work, they were considering a social media application, that was collecting user positions to show nearby friends. Their work not only showcased that you can apply z-order encoding to encode positions, but comes really handy when using preference levels for positions sharing. Let's consider the following example: a user wants to share his position with a friend, but he knows that that friend is not trusted enough to share his exact location. Instead, he can apply a preference bit-mask in order to share only a certain order level of the z-order encoding. The paper also shows that is possible to compute the exact distance between two positions: the main idea is to create the smallest encoded box that contains both positions. This concept could be applied to our protocol, allowing us not only to find parkings sharing our same area, but also to compute the distance between a particular parking.


Our encoding standard is based on the transformation of GPS coordinates into a z-order curve, thus an approximate representation of an area. When applying this encoding, we need to consider the order of magnitude of the error introduced by the encoding. That doesn't always mean that the error is negligible, but at the same time could also work in our favor, as it allows to obfuscate an exact position.

TODO: add considerations on which protocol to use sub/pub req resp.
