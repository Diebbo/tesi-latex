\documentclass[12pt,a4paper,twoside]{book}


\usepackage[utf8]{inputenc}
\usepackage[a4paper,inner=3.5cm,outer=2.5cm]{geometry}

\usepackage[titletoc,title,toc,page]{appendix}
\usepackage{verbatim}
\usepackage{placeins}
\usepackage{listings}
\usepackage{hyperref}
\usepackage[english]{babel}
\usepackage{tikz}
\usepackage{parskip}

\usepackage{graphicx}
\usepackage{blindtext}
\usepackage{chngcntr}
\counterwithin{table}{chapter}

\usepackage{newlfont}
\usepackage{fancyhdr}
\usepackage{indentfirst}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage{hyperref}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{soul}
\usepackage[font=footnotesize,labelfont=bf]{caption}

\usepackage{multirow}
\usepackage{hyphenat}
\hyphenation{mate-mati-ca recu-perare}

\usepackage{lscape} 

\usepackage{natbib}
\bibliographystyle{alpha}
\setcitestyle{super,open={[},close={]}}

\newcommand{\rom}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

\usepackage{pdfpages}

\begin{document}
% Per spostare i vari elementi più su o più giù gioca con i valori di vspace che ci sono tra uno e l'altro
\pagestyle{empty}
\newgeometry{
    left=20mm,
    right=20mm,
    top=20mm,
    bottom=20mm
}

\begin{titlepage}

\begin{center}

% marchio di ateneo
\includegraphics[width=6.5cm,height=4.7cm]{img/marchio-di-ateneo.png}

\vspace{10mm}

% \large is 12pt
{\large{\bf{Dipartimento di Scienze e Ingegneria informatica}}} 

\vspace{5mm}

% \Large is 14.4pt
{\Large{\bf{Corso di Laurea in Informatica}}}

\vspace{15mm}

{\Huge{\bf Homomorphic Encryption Applications }}\\
\vspace{3mm}
{\Huge{\bf on the LA-MQTT Protocol}}\\
\vspace{3mm}

\end{center}

\vspace{10mm}

\begin{minipage}[t]{0.40\textwidth}
{\Large{\bf Relatore: \\ Chiar.mo Prof.\\ Federico Montori}}

\vspace{3mm}

{\Large{\bf Correlatore: \\ Chiar.mo Prof.\\ Saverio Giallorenzo}}
\end{minipage}
\hfill
\begin{minipage}[t]{0.40\textwidth}\raggedleft
{\Large{\bf Presentata da: \\ Diego Barbieri}}
\end{minipage}

\vspace{30mm}

\rule[0.5cm]{15.8cm}{0.6mm}

\begin{center}
{\large{\bf Sessione mese anno \\}}
{\large{\bf Anno Accademico 2024/2025\\}}
\end{center}

\end{titlepage}

\restoregeometry
\newpage
\begin{center}
    (DA FARE ALLA FINE)\\
    5 parole chiave per caratterizzare il contenuto della dissertazione:\\ (se non ti piacciono così sparse puoi anche semplicemente scriverle su una riga sola)
\end{center}

% https://tex.stackexchange.com/questions/26538/words-scattered-randomly-in-on-coverpage
\begin{tikzpicture}[overlay,remember picture,shift=(current page.center)]
\pgfmathsetseed{3}


\foreach [count=\count] \word in {Parola 1, parola 2, parola 3, parola 4, parola 5} {
\node [
    xshift={(mod(\count,3)-1)*(\paperwidth/4)},
    yshift={(mod(\count,7)-3)*(\paperwidth/6)},
    xshift=rand*4cm,
    yshift=rand*2cm,
    % rotate=rand*35,
    % opacity=rnd*0.5+0.125,
    font=\large] {\word};
}
\end{tikzpicture}
\newpage

\topmargin=6.5cm
\begin{flushright}
\emph{
\LARGE{La dedica}\\\vspace{2mm}
\LARGE{anche quella se vuoi}\\\vspace{3mm} 
\LARGE{su più righe} 
}
\end{flushright}
\newpage~\newpage
\pagenumbering{gobble}
\chapter*{Abstract}
Abstract qui (ti consiglio di farlo alla fine)

\topmargin=-1cm
\tableofcontents
\thispagestyle{empty}
\listoftables
\thispagestyle{empty}
\listoffigures
\thispagestyle{empty}
\newpage~\newpage


\pagenumbering{arabic}
\setcounter{chapter}{-1}
\raggedbottom
\chapter{Introduction} \label{chap:intro}
\pagestyle{plain}
\setcounter{page}{1}




\chapter{Background}
\section{Request-Response Protocol}
The Request-Response protocol is a fundamental communication pattern in distributed systems where a client sends a request to a server and waits for a response. This synchronous communication model is characterized by its simplicity and direct interaction between parties, making it suitable for operations requiring immediate feedback and confirmation.

\section{Publish-Subscribe Protocol}
The Publish-Subscribe (Pub/Sub) protocol is an asynchronous messaging pattern where senders (publishers) categorize messages into topics without knowledge of the receivers (subscribers). Subscribers express interest in specific topics and receive messages published to those topics. This decoupled architecture enables scalable and flexible communication in distributed systems.

\subsection{MQTT}
MQTT (Message Queuing Telemetry Transport) is a lightweight, open-source messaging protocol designed for constrained devices and low-bandwidth, high-latency networks. It implements the publish-subscribe pattern over TCP/IP, providing three quality of service levels for message delivery and supporting various security features.

\subsection{LA-MQTT}
LA-MQTT (Location-Aware MQTT) extends the standard MQTT protocol by incorporating location-based features. It enables spatial queries and location-aware message routing, making it particularly suitable for IoT applications requiring geographical context in message distribution.

\section{Universal Location Referencing}
Universal Location Referencing provides standardized methods for encoding and representing geographical locations. These systems ensure consistent and unambiguous location representation across different applications and platforms.

\subsection{Cantor Pairing}
Cantor Pairing is a mathematical technique that uniquely maps two natural numbers to a single natural number. This bijective function is particularly useful in computer science for combining two coordinates into a single value while maintaining the ability to recover the original coordinates.

\subsection{MGRS}
The Military Grid Reference System (MGRS) is a geocoordinate system used by NATO militaries for locating points on Earth. It provides a concise way to represent locations using a combination of letters and numbers, offering high precision and ease of use in military and civilian applications.

\section{Space Filling Curves}
Space Filling Curves are mathematical curves that pass through every point in a multi-dimensional space. They provide a way to map multi-dimensional data to a single dimension while preserving spatial locality, making them valuable for spatial indexing and data organization.

\section{Privacy Preserving}
Privacy Preserving techniques ensure the protection of sensitive information while allowing necessary computations and data processing. These methods are crucial in maintaining confidentiality in distributed systems and data analysis.

\subsection{Homomorphic Encryption}
Homomorphic Encryption is a form of encryption that allows specific types of computations to be performed on ciphertext, producing an encrypted result that, when decrypted, matches the result of operations performed on the plaintext.

\subsubsection{Fully Homomorphic Encryption}
Fully Homomorphic Encryption (FHE) enables arbitrary computations on encrypted data without decryption. It allows for complex operations while maintaining data privacy, though it comes with significant computational overhead.

\subsubsection{Partially Homomorphic Encryption}
Partially Homomorphic Encryption (PHE) supports specific types of operations (like addition or multiplication) on encrypted data. While more limited than FHE, it offers better performance and is suitable for applications requiring specific mathematical operations.

\section{Usage of HE for Matching}
Homomorphic Encryption can be applied to matching problems, allowing secure computation of relationships between encrypted data points while maintaining privacy.

\subsection{Distance Calculation}
Distance calculation using Homomorphic Encryption enables secure computation of distances between encrypted coordinates, crucial for location-based services that need to maintain user privacy.

\subsection{Parkings Availability}
The application of Homomorphic Encryption to parking availability systems allows for secure matching between user locations and available parking spots while protecting the privacy of both users and parking infrastructure.

\subsection{PHE and FHE Implications}
The choice between Partially and Fully Homomorphic Encryption has significant implications for system performance, security, and functionality. PHE offers better performance but limited operations, while FHE provides full computational capabilities at the cost of higher computational overhead.

\chapter{System Architecture}
\section{System Overview}
\section{Actors}
\subsection{LDS}
\subsection{MC}
\subsection{Broker}
\subsection{Worker}
\section{Client}
\section{Server}

\chapter{Protocol Design}
\section{Protocol Overview}
\subsection{Position Publish}
\subsection{Area Subscription}
\subsection{Geofence Publish}

\chapter{Testing}

\chapter{Performance Evaluation}

\chapter{Project}
\section{Glossary}
\begin{itemize}
    \item LDS: Sensors
    \item MC: Clients
\end{itemize}

\section{Project Idea}
L'idea centrale consiste nell'applicare i principi della \emph{homomorphic encryption} al protocollo \emph{LA-MQTT}. Quando un client invia un aggiornamento di posizione, questa viene trasmessa in forma cifrata mediante Fully Homomorphic Encryption (FHE). Il server esegue un'analisi sulle posizioni disponibili, appartenenti alla stessa area geografica, e dopo aver effettuato un controllo con la chiave di verifica, restituisce un blob cifrato contenente le distanze calcolate.

\subsection{Funzionalità Principali}
\begin{itemize}
    \item \textbf{Position Publish}: Il client aggiorna la propria posizione per ricevere informazioni dai publisher relativamente ai sensori presenti nell'area di interesse.
    \begin{itemize}
        \item $Enc(GPS\_DATA)$
        \item $P_{i}$: Posizione
    \end{itemize}
    
    \item \textbf{Area Subscription}: Un client si sottoscrive a un'area di interesse. Per ogni aggiornamento di posizione viene effettuato un controllo su tutte le posizioni riportate fino a quel momento appartenenti all'area.
    \begin{itemize}
        \item $C(i, t_{s})$
    \end{itemize}
    
    \item \textbf{Geofence Publish}: Permette ai client LDS di pubblicare un blob contenente:
    \begin{itemize}
        \item Dati geofence (formato GEOJSON RFC 7946)
        \item $g_s$: geofence target
        \item $c_{s}$: contenuto pubblicizzato
        \item $t_{s}$: topic
        \item $e_{s}$: evento di mobilità
    \end{itemize}
\end{itemize}

\section{Attori del Sistema}
\begin{itemize}
    \item \textbf{Broker/Proxy}: Gestisce le chiavi di tutti i client che hanno effettuato almeno una sottoscrizione
    \item \textbf{Publisher}: Pubblicano aggiornamenti sulle posizioni disponibili
    \item \textbf{Subscriber}: Sottoscrivono aree geografiche e ricevono aggiornamenti sui parcheggi disponibili
\end{itemize}

\section{Vantaggi}
\begin{itemize}
    \item Dati sempre cifrati
    \item In caso di \emph{re-encryption}, solo il proxy conosce le posizioni decifrate dei sensori
    \begin{itemize}
        \item Un proxy malevolo non compromette la posizione dell'utente
        \item Possibile individuare proxy fittizi mediante falsi aggiornamenti di posizione
    \end{itemize}
\end{itemize}

\section{Svantaggi}
\begin{itemize}
    \item Latenze significative (worker)
    \item Attenzione necessaria alla triangolazione delle posizioni
\end{itemize}

\section{Stack Tecnologico}
\begin{itemize}
    \item \textbf{Soluzione ad alte prestazioni}:
    \begin{itemize}
        \item C++ SEAL (Microsoft)
        \item Rust TFHE-rs (ZAMA)
    \end{itemize}
    \item \textbf{Proof of Concept}:
    \begin{itemize}
        \item Python Concrete (ZAMA)
    \end{itemize}
\end{itemize}

\section{Interrogativi Aperti}
\begin{itemize}
    \item \textbf{Prestazioni}: È accettabile un delay di 5-10 secondi per l'analisi dei dati?
    \item \textbf{Re-encryption}: È una soluzione eccessiva?
    \begin{itemize}
        \item Il server salva le posizioni cifrate nel database
        \item Possibile alternativa: Private Set Intersection (PSI)
    \end{itemize}
    \item \textbf{Architettura}: Request-Response vs MQTT
\end{itemize}

\section{Sviluppi Futuri}
\begin{itemize}
    \item Integrazione della libreria \emph{SEAL Embedded} per i sensori
    \item Definizione della funzione per il calcolo delle distanze
    \item Analisi degli ordini di grandezza degli errori
    \item Selezione delle posizioni rilevanti:
    \begin{itemize}
        \item Area poligonale (due punti)
        \item Area discreta (MGRS)
    \end{itemize}
    \item Deduplicazione di vettori numerici
    \item Ottimizzazione delle richieste per evitare attacchi DoS
    \begin{itemize}
        \item Dimostrazione delle vulnerabilità nell'implementazione precedente
        \item Proposta di patch risolutive
    \end{itemize}
\end{itemize}


\section{riferimenti}
Come detto prima le label servono per riferirsi ad altre parti del testo citate precendentemente.\\
Ti consiglio di metterle sempre almeno a figure. immagini e capitoli.

Per riferirti a qualcosa basta fare ref seguito dal nome della label, ad esempio ``vedi capitolo \ref{chap:intro}''.\\In questo modo dal pdf cliccando sulla reference, ti porta direttamente al punto giusto.
Altri pacchetti come \texttt{fancyref} e \texttt{cleveref} (consigliato) possono aiutare nell'automatizzare la creazione delle refrence. Usando ad esempio \texttt{\cref{chap:intro}} viene generata la dicitura corrispondete all'elemento a cui si fa riferimento, seguita dalla numerazione. Eccone un esempio: \cref{chap:intro}.
\section{citazioni}
Per citare si usa cite seguito dal nome dell'articolo nel file.bib, ad esempio ``come visto nell'articolo di tizio\cite{greenwade93}''.

Se non ti piace lo stile di citazione puoi modificarlo sopra dove scrivo usepackage natbib, ma quello impostato attualmente dovrebbe andare bene.



\renewcommand{\bibsection}{}
\chapter*{Riferimenti bibliografici}
\bibliography{refs}
\newpage

\renewcommand{\appendixtocname}{Appendici}
\renewcommand{\appendixpagename}{Appendici}
% \csname @openrightfalse\endcsname
\pagenumbering{gobble}

\newpage~\newpage
\chapter*{Ringraziamenti}
Grazie a tutti
\end{document}
